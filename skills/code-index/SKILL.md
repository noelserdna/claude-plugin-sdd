---
name: code-index
description: "Index project code for deep traceability. Bridges GitNexus code intelligence with SDD artifacts — maps call graphs, symbols, and execution flows to requirements. Use after implementation or before reconciliation. Invoke with /sdd:code-index"
---

# SDD Code Index — GitNexus Bridge

**Version**: 1.0.0
**SWEBOK**: Ch11 (Software Construction), Ch08 (Software Testing — structural coverage)
**Purpose**: Enrich the SDD traceability graph with structural code intelligence by bridging GitNexus analysis with SDD artifact references.

## Trigger Phrases

- `/sdd:code-index`
- "index code for traceability"
- "enrich code references"
- "connect code to requirements"
- "map call graph to SDD"

## Prerequisites

- A project with source code in `src/` (or configurable root)
- Existing SDD artifacts (at least `requirements/` and `spec/`)
- `dashboard/traceability-graph.json` generated by `/sdd:dashboard`
- **Optional**: GitNexus installed (`npm install -g gitnexus`) for deep analysis

## Modes

| Mode | Flag | Description |
|------|------|-------------|
| **Full** | (default) | Full GitNexus analysis + SDD mapping |
| **Lite** | `--lite` | Enhanced regex-based analysis without GitNexus (no AST/call graph) |
| **Status** | `--status` | Check if code index is current, report staleness |
| **Refresh** | `--refresh` | Re-run only for files changed since last index |

## Process

### Phase 1: Environment Check

1.1. Verify `dashboard/traceability-graph.json` exists
  - IF missing: suggest running `/sdd:dashboard` first → STOP

1.2. Check GitNexus availability:
```bash
npx gitnexus --version 2>/dev/null
```
  - IF available: proceed with Full mode
  - IF not available AND mode is Full:
    - Present option table:
      | Option | Description |
      |--------|-------------|
      | A) Install GitNexus | `npm install -g gitnexus` then continue |
      | B) Use Lite mode | Enhanced regex analysis (no call graph) |
      | C) Cancel | Stop execution |

1.3. Read current `traceability-graph.json` into memory

### Phase 2: Code Analysis (Full Mode — GitNexus)

2.1. Run GitNexus analysis on the project:
```bash
npx gitnexus analyze
```

2.2. Query GitNexus MCP for all exported symbols:
- Use `gitnexus_query({ query: "all exported functions and classes" })`
- Collect: name, type, filePath, startLine, endLine, isExported

2.3. For each symbol, query context:
- Use `gitnexus_context({ name: symbolName })` → callers, callees, processes

2.4. Scan each symbol's source location for `Refs:` annotations:
- Search backward up to 10 lines from symbol definition for `// Refs:` or `# Refs:` comments
- Extract artifact IDs (REQ-*, UC-*, INV-*, etc.)

### Phase 3: Code Analysis (Lite Mode — Regex)

3.1. Scan `src/**/*.{ts,js,tsx,jsx,py,java,go,rs,cs,rb}` for:
- Function/class/method declarations (regex per language)
- `Refs:` annotation comments within 10 lines of declarations

3.2. Build symbol table:
- name, type (function/class/method/const), filePath, startLine
- No callers/callees/processes (requires AST)

3.3. Mark all refs as `direct` (no inference possible without call graph)

### Phase 4: SDD Mapping

4.1. For each symbol with `Refs:` annotations:
- Map referenced artifact IDs to the traceability graph
- Create `artifactRefs[]` entries on the symbol

4.2. **Transitive inference** (Full mode only):
- For each annotated symbol, walk its callers (from GitNexus call graph)
- For each caller WITHOUT its own `Refs:` annotation:
  - Infer that the caller implements the same artifacts
  - Add to `inferredRefs[]` with flag `inferred: true`
  - Propagation depth: max 2 levels (caller of caller)

4.3. **Process mapping** (Full mode only):
- For each GitNexus execution flow/process:
  - Collect all artifact refs from steps in the flow
  - Map process to SDD artifacts
  - Create `processes[]` entries

4.4. **Community detection** (Full mode only):
- Group symbols by their GitNexus community assignments
- Map communities to SDD business domains (from classification)

### Phase 5: Graph Enrichment

5.1. Build `codeIntelligence` block for `traceability-graph.json`:
```json
{
  "codeIntelligence": {
    "indexed": true,
    "indexedAt": "ISO-8601",
    "engine": "gitnexus" | "regex-lite",
    "engineVersion": "x.y.z",
    "symbols": [...],
    "callGraph": [...],
    "processes": [...],
    "stats": {
      "totalSymbols": N,
      "symbolsWithRefs": N,
      "symbolsWithInferredRefs": N,
      "uncoveredSymbols": N,
      "totalProcesses": N,
      "processesWithRefs": N
    }
  }
}
```

5.2. Enrich existing `codeRefs[]` on artifacts:
- For symbols with `inferredRefs`, add new codeRef entries to the target artifacts
- Set `inferred: true` flag on these entries (schema v4 extension)

5.3. Add new relationships to `relationships[]`:
- Type: `inferred-implements` for transitively inferred code→artifact links
- Include confidence score based on call graph distance

5.4. Update `statistics.codeStats` with enriched counts

### Phase 6: Write & Report

6.1. Write updated `dashboard/traceability-graph.json`
  - Bump `$schema` to `"traceability-graph-v4"` if codeIntelligence added
  - Preserve all existing data (backward compatible)

6.2. Generate enrichment report:

```markdown
# Code Index Report

## Summary
- Engine: GitNexus v1.x.x / regex-lite
- Indexed at: 2026-03-01T15:00:00Z
- Total symbols: 340
- Symbols with direct refs: 120 (35%)
- Symbols with inferred refs: 80 (24%)
- Uncovered symbols: 140 (41%)
- Execution flows mapped: 45
- Flows with SDD refs: 28 (62%)

## Top Uncovered Symbols
| Symbol | File | Type | Callers | Why Uncovered |
|--------|------|------|---------|---------------|
| processPayment | src/payment/processor.ts | function | 5 | No Refs annotation, no annotated callers |

## Inferred Mappings
| Symbol | File | Inferred From | Artifact | Confidence |
|--------|------|---------------|----------|------------|
| handleLogin | src/routes/auth.ts | calls validateUser | UC-AUTH-001 | 0.9 |

## Recommendations
1. Add `// Refs: UC-PAY-001` to processPayment() — 5 callers will gain coverage
2. ...
```

6.3. Output report to `code-intelligence/CODE-INDEX-REPORT.md`

## Constraints

- **C-01**: Never modify source code files (no auto-injection of Refs: comments)
- **C-02**: Transitive inference max depth = 2 (beyond 2 levels, confidence too low)
- **C-03**: Confidence threshold for inferred refs = 0.7 (below this, mark as "suggested" not "inferred")
- **C-04**: GitNexus is optional — the skill MUST work in Lite mode without it
- **C-05**: Preserve all existing graph data — the codeIntelligence block is additive only
- **C-06**: If traceability-graph.json doesn't exist, direct user to `/sdd:dashboard` first

## Output Artifacts

| Artifact | Location | Description |
|----------|----------|-------------|
| Enriched graph | `dashboard/traceability-graph.json` | Updated with codeIntelligence block |
| Index report | `code-intelligence/CODE-INDEX-REPORT.md` | Enrichment summary and recommendations |

## Integration with Other Skills

| Skill | How It Uses Code Index |
|-------|----------------------|
| `/sdd:dashboard` | Renders code intelligence tab, enriched code coverage view |
| `/sdd:req-change` | Uses call graph for blast radius (Phase 2 Step 7) |
| `/sdd:traceability-check` | Verifies code/test chain integrity (Step 5.5) |
| `/sdd:reconcile` | Uses symbol table for code scan (Phase 2) |
| `/sdd:reverse-engineer` | Can consume existing code index to accelerate analysis |
