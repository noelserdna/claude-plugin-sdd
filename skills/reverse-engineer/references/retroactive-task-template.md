# Retroactive Task Template

> Formato para tasks retroactivos generados por `reverse-engineer`. Sigue el mismo formato que `task-generator` pero con marcadores `[RETROACTIVE]` y estado `[x]` (completado). Utilizado por la Fase 9.

---

## 1. Task File Format

Each task file follows the `task/TASK-FASE-{N}.md` format, identical to forward-pipeline tasks but with retroactive markers.

```markdown
# Tasks — Fase {N}: {Phase Title} [RETROACTIVE]

> Generated by: `reverse-engineer`
> Generated: {ISO-8601}
> Status: All tasks pre-completed (retroactive documentation)
> Source: Reverse engineering of existing codebase

---

## TASK-F{N}-001: {Task Title} [RETROACTIVE]

- [x] **Status:** Completed (retroactive)
- **Refs:** REQ-{GROUP}-{NNN}, UC-{NNN}
- **Phase:** FASE-{N}
- **Files:**
  - Source: `{src/path/file.ext}`
  - Test: `{tests/path/file.test.ext}` (or `[NO-TEST]` if missing)
- **Commit:** `{SHA}` (or `[NO-COMMIT]` if not traceable)
- **Revert strategy:** `RETROACTIVE — already in production`

### Description

{What this code implements, derived from code analysis}

### Implementation Notes

- **Pattern detected:** {design pattern or architectural approach found}
- **Dependencies:** {external and internal dependencies}
- **Confidence:** {HIGH|MEDIUM|LOW} {[INFERRED] if applicable}

### Acceptance Criteria (Retroactive)

Based on existing behavior:

\`\`\`gherkin
Given {precondition observed in code/tests}
When {action/trigger}
Then {postcondition/assertion from tests or code behavior}
\`\`\`

### Review Checklist (Retroactive)

- [x] Code exists and functions
- [ ] Requirements extracted and validated — `REQ-{GROUP}-{NNN}`
- [ ] Specification coverage verified
- [ ] Test coverage adequate (or gap documented)
- [ ] Findings documented (dead code, tech debt, workarounds)
- [ ] Traceability chain established

---
```

---

## 2. Commit SHA Resolution

### Finding the Commit

For each task, attempt to find the original commit:

1. **Primary:** Search git log for the main source file:
   ```bash
   git log --follow --format="%H %s" -- {file_path} | head -1
   ```
   Use the first (oldest) commit that introduced the file.

2. **Refinement:** If the file was significantly modified later, use the commit that introduced the specific feature:
   ```bash
   git log --all -S "{function_name}" --format="%H %s" -- {file_path}
   ```

3. **Fallback:** If the file has too many commits or the feature can't be isolated:
   ```
   Commit: [NO-COMMIT] — feature spans multiple commits
   ```

### Commit Field Format

```markdown
- **Commit:** `abc1234` — "feat: add user authentication" (2024-03-15)
```

or

```markdown
- **Commit:** `[NO-COMMIT]` — unable to isolate; feature evolved over 15 commits (2023-06 to 2024-01)
```

---

## 3. Revert Strategy

All retroactive tasks use a fixed revert strategy:

```markdown
- **Revert strategy:** `RETROACTIVE — already in production`
```

This indicates:
- The code is already deployed and running
- Reverting is not applicable (the task documents existing state)
- If removal is desired, a new forward task should be created via `req-change`

---

## 4. Task Status Markers

| Marker | Meaning |
|--------|---------|
| `[x]` | Task completed (code exists) |
| `[RETROACTIVE]` | Task documents existing code, not new development |
| `[NO-TEST]` | No test file found for this functionality |
| `[NO-COMMIT]` | Original commit cannot be isolated |
| `[INFERRED]` | Requirements/specs were inferred from code |
| `[PARTIAL]` | Implementation exists but is incomplete |

---

## 5. Grouping Rules

Tasks should be grouped into phases based on the architecture plan generated in Phase 8:

| Phase Type | Grouping Criterion | Example |
|-----------|-------------------|---------|
| Infrastructure | Cross-cutting: auth, logging, config, DB setup | FASE-1: Project Infrastructure |
| Domain model | Entity definitions, schemas, migrations | FASE-2: Domain Model |
| Core services | Business logic, service layer | FASE-3: Core Services |
| API layer | Routes, controllers, middleware | FASE-4: API Layer |
| Integration | External service connections | FASE-5: External Integrations |
| Background | Workers, cron jobs, queues | FASE-6: Background Processing |
| Frontend | UI components (if applicable) | FASE-7: Frontend |

The exact phase structure depends on the project's architecture detected in Phase 8.

---

## 6. Test Coverage Annotation

For each task, annotate test coverage status:

```markdown
### Test Coverage

| Source File | Test File | Coverage | Status |
|------------|-----------|----------|--------|
| `src/auth/jwt.ts` | `tests/auth/jwt.test.ts` | 85% | Adequate |
| `src/auth/roles.ts` | `[NO-TEST]` | 0% | **GAP** — needs tests |
| `src/auth/session.ts` | `tests/auth/session.test.ts` | 30% | **LOW** — needs improvement |
```

Status values:
- **Adequate**: Coverage >= 80% for domain logic, >= 60% for infrastructure
- **LOW**: Coverage exists but below threshold
- **GAP**: No test file exists — creates a forward task recommendation

---

## 7. Forward Task Generation

When retroactive analysis reveals gaps, generate forward (pending) tasks:

```markdown
## TASK-F{N}-{NNN}: Add tests for {module} [FORWARD]

- [ ] **Status:** Pending
- **Refs:** REQ-{GROUP}-{NNN}
- **Reason:** Gap detected during reverse engineering
- **Gap type:** {NO-TEST | LOW-COVERAGE | MISSING-VALIDATION | MISSING-ERROR-HANDLING}
- **Priority:** {based on severity from findings}

### Description

{What needs to be implemented to close the gap}
```

Forward tasks are clearly distinguished from retroactive ones by:
- `[ ]` (unchecked) vs `[x]` (checked)
- `[FORWARD]` marker vs `[RETROACTIVE]` marker
- Standard revert strategy (SAFE/COUPLED/MIGRATION) vs `RETROACTIVE`
