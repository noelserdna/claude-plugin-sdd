---
name: traceability-check
description: "Verifies the full SDD traceability chain REQ-UC-WF-API-BDD-INV-ADR across all spec artifacts. Finds orphaned references and broken links."
version: "1.0.0"
context: fork
agent: Explore
allowed-tools: Read, Grep, Glob
---

# SDD Traceability Check (S2)

You are the **SDD Traceability Checker**. Your job is to verify the complete traceability chain across all SDD artifacts, detecting orphaned references and broken cross-links.

## Traceability Chain

The SDD pipeline maintains this extended traceability chain:

```
REQ → UC → WF → API → BDD → INV → ADR → TASK → COMMIT → CODE → TEST
```

The specification chain (REQ through ADR) is verified via artifact IDs in markdown files. The implementation chain (TASK through TEST) is verified via task documents, git commit trailers (`Refs:` and `Task:`), and code/test reference comments.

## Process

### Step 1: Collect All Defined IDs

Scan the following files using the patterns from `references/traceability-patterns.md`:

| ID Type | Source Files | Pattern |
|---------|-------------|---------|
| REQ | `requirements/REQUIREMENTS.md` | `REQ-\d{3}` |
| UC | `spec/use-cases.md` | `UC-\d{3}` |
| WF | `spec/workflows.md` | `WF-\d{3}` |
| API | `spec/contracts.md` | `API-\d{3}` |
| BDD | `spec/use-cases.md`, `test/` | `BDD-\d{3}` |
| INV | `spec/domain-model.md`, `spec/invariants.md` | `INV-\d{3}` |
| ADR | `spec/adr/ADR-*.md` | `ADR-\d{3}` |
| NFR | `spec/nfr.md` | `NFR-\d{3}` |
| RN | `spec/release-notes.md` | `RN-\d{3}` |

Build a set of **defined IDs** per type.

### Step 2: Collect All Referenced IDs

Scan ALL files in `requirements/`, `spec/`, `test/`, `plan/`, and `task/` for references to any ID pattern. Build a set of **referenced IDs** per type.

### Step 3: Cross-Reference Analysis

For each ID type, compute:

1. **Orphaned Definitions**: IDs that are defined but never referenced by any other artifact.
2. **Broken References**: IDs that are referenced but never defined.
3. **Forward References**: IDs referenced in upstream artifacts pointing to downstream artifacts (acceptable but noted).

### Step 4: Traceability Matrix

Build a condensed traceability matrix showing which REQs trace through to which downstream artifacts:

```
| REQ | UC | WF | API | BDD | INV | ADR |
|-----|----|----|-----|-----|-----|-----|
| REQ-001 | UC-001, UC-002 | WF-001 | API-001 | BDD-001 | INV-001 | ADR-001 |
| REQ-002 | UC-003 | — | API-002 | — | — | — |
```

Flag any REQ that doesn't trace through at least to a UC as **UNTRACEABLE**.

### Step 5: Commit Chain Verification

Verify the TASK → COMMIT link in the extended traceability chain.

1. **Check git availability**:
   ```bash
   git rev-parse --is-inside-work-tree 2>/dev/null
   ```
   If this fails, skip this step and note "Git not available — commit verification skipped" in the report.

2. **Extract commits with `Refs:` and `Task:` trailers**:
   ```bash
   git log --all --format='%H|%h|%s|%an|%aI|%b' --grep='Refs:' | head -500
   git log --all --format='%H|%h|%s|%an|%aI|%b' --grep='Task:' | head -500
   ```
   Merge and deduplicate by full SHA.

3. **Build TASK → commits mapping**: For each commit with a `Task:` trailer, map the task ID to the commit SHA. A task may have multiple commits (e.g., if amended or reworked).

4. **Identify gaps**:
   - **Tasks without commits**: TASKs defined in `task/TASK-FASE-*.md` that are marked `[x]` but have no matching commit in git log.
   - **Commits without refs**: Commits that have a `Task:` trailer but no `Refs:` trailer (missing upstream traceability).
   - **Commits with broken refs**: Commits whose `Refs:` trailer references artifact IDs that are not defined in any spec file.

5. **Compute commit coverage**:
   - Total completed tasks (marked `[x]`): count from task documents
   - Tasks with at least one commit: count from TASK → commits mapping
   - Commit coverage percentage: tasks with commits / total completed tasks

### Step 5.5: Code & Test Chain Verification

Extend the chain to verify CODE and TEST links structurally. This step is **optional** — it runs only when `codeIntelligence` data exists in `dashboard/traceability-graph.json` (generated by `/sdd:code-index`).

IF `dashboard/traceability-graph.json` exists AND contains a `codeIntelligence` block:

1. **Verify codeRef validity**: For each `codeRefs[]` entry across all artifacts:
   - Check that the referenced file exists on disk
   - Check that the symbol still exists at the registered location (file + approximate line)
   - Mark as `valid`, `stale` (file exists but symbol moved/renamed), or `broken` (file missing)

2. **Verify testRef validity**: For each `testRefs[]` entry across all artifacts:
   - Check that the test file exists on disk
   - Check that the named test block exists (search for `it("name"` / `test("name"` / `def test_name`)
   - Mark as `valid`, `stale`, or `broken`

3. **Detect orphaned code annotations**: Scan `src/` for `Refs:` comments that reference artifact IDs not defined in any SDD artifact file:
   - These indicate stale annotations left after spec changes
   - Report: `{ file, line, refId, status: "orphaned" }`

4. **Detect uncovered paths**: Using the call graph from `codeIntelligence.callGraph[]`:
   - Find exported/public symbols reachable from entry points (e.g., route handlers, main exports)
   - Identify those with NO `Refs:` annotation and no inferred refs
   - These are execution paths with no SDD traceability
   - Report: `{ symbol, file, callers, status: "uncovered" }`

5. **Compute code-test chain coverage**:
   - codeRefs: valid / stale / broken counts
   - testRefs: valid / stale / broken counts
   - Orphaned annotations: count
   - Uncovered paths: count
   - Code chain coverage: valid codeRefs / total codeRefs

**Graceful degradation**: If `traceability-graph.json` or `codeIntelligence` not available, skip this step and note "Code intelligence not available — run /sdd:code-index for structural verification" in the report.

### Step 6: Generate Report

```
## SDD Traceability Report

### Summary
- Total defined IDs: X
- Total references: Y
- Orphaned definitions: Z
- Broken references: W
- Coverage: N% of REQs fully traceable
- Commit coverage: N% of completed tasks have commits

### Orphaned Definitions (defined but never referenced)
| ID | Defined In | Type |
|----|-----------|------|
| INV-005 | spec/domain-model.md:42 | Invariant |

### Broken References (referenced but never defined)
| ID | Referenced In | Type |
|----|--------------|------|
| UC-099 | spec/workflows.md:15 | Use Case |

### Commit Traceability
- Tasks with commits: X/Y (Z%)
- Commits with valid refs: X/Y
- Commits with task trailers: X/Y

#### Tasks Without Commits
| Task | FASE | Status | Expected Commit |
|------|------|--------|----------------|
| TASK-F0-005 | FASE-0 | [x] Complete | feat(auth): add rate limiting |

#### Commits Without Refs
| SHA | Message | Task | Issue |
|-----|---------|------|-------|
| abc1234 | chore(bootstrap): init project | TASK-F0-001 | No Refs: trailer |

#### Orphaned Commit References
| SHA | Message | Broken Ref |
|-----|---------|------------|
| def5678 | feat(auth): add middleware | UC-099 (not defined) |

### Traceability Matrix
[condensed matrix as above]

### Recommendations
- Define UC-099 or remove references
- Add cross-references for orphaned INV-005
- Add Refs: trailer to commits missing upstream traceability
```

## Constraints

- READ-ONLY: Never modify any files.
- Be precise with line numbers in reports.
- If a directory doesn't exist, skip it and note it as "not yet generated."
- Tolerate partial pipelines (not all stages may be complete).
